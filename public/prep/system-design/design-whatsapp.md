# Design WhatsApp (Chat App) ðŸ’¬

## 1. The "Post Office" Analogy

You write a letter (Message) to a friend.
1.  **Drop off:** You put it in the mailbox (Server).
2.  **Delivery:** The mailman delivers it to your friend's house.
3.  **Acknowledgement:** You get a receipt that it was delivered.

**The Complexity of WhatsApp:**
*   **Real-time:** Delivery must be milliseconds, not days.
*   **Offline:** What if the friend isn't home? (Store and Forward).
*   **Security:** Even the mailman (Server) cannot read the letter (End-to-End Encryption).

---

## 2. Core Constraints & Requirements

**Functional:**
*   1-on-1 Chat and Group Chat.
*   Sent / Delivered / Read receipts.
*   Last Seen / Online Status.
*   Media sharing (Images/Video).

**Non-Functional:**
*   **Massive Concurrency:** 2 Billion users.
*   **Low Latency:** Real-time delivery.
*   **Privacy:** E2E Encryption (Signal Protocol).
*   **Storage:** Messages are stored on *Device*, ephemeral on Server (mostly).

---

## 3. High-Level Architecture ðŸ—ï¸

```visualizer
{
  "type": "architecture-diagram",
  "content": "graph TD\n    Alice[Alice (User)]-->|WS Connection| GTW_A[Chat Gateway A]\n    Bob[Bob (User)]-->|WS Connection| GTW_B[Chat Gateway B]\n    \n    GTW_A-->|Route Msg| Router[Session / Router Service]\n    Router-->|Lookup Bob| Redist[(Redis - User Location)]\n    \n    Router-->|Forward| GTW_B\n    GTW_B-->|Push| Bob\n    \n    subgraph Offline Handling\n    GTW_B -.->|Bob Offline| DB[(Temp Message Store)]\n    end"
}
```

---

## 4. Connection Protocol: WebSocket vs MQTT vs XMPP

**Why not HTTP (REST)?**
*   HTTP is client-initiated. Server cannot "Push" a message to Bob without Polling (inefficient) or Long Polling.

**The Solution: Persistent Connections**
1.  **WebSocket:** Full duplex TCP connection. Low overhead.
2.  **MQTT (Message Queuing Telemetry Transport):** Lightweight, originally for oil pipelines (IoT). Great for unstable mobile networks (battery efficient).
3.  **XMPP (Extensible Messaging and Presence Protocol):** XML-based. Used by original WhatsApp, but heavily customized to be binary (compact) because XML is bloated.

**Connection Handler:**
*   Servers maintain millions of open TCP connections.
*   **Erlang/Elixir:** WhatsApp allows ~2 million connections per server using Erlang (BEAM VM) lightweight processes.

---

## 5. Scenario A: Message Delivery Flow (Store and Forward)

**Flow:**
1.  **Alice writes:** "Hello" (encrypted).
2.  **Gateway:** Receives message.
    *   ACKs to Alice: "Server Received" (Single Tick âœ“).
3.  **Session Check:** Is Bob connected?
    *   **Yes:** Push to Bob's Gateway -> Bob.
    *   **No:** Store in **Temporary DB** (Cassandra/HBase).
4.  **Bobs comes online:**
    *   Gateway pushes pending messages.
    *   Deletes from Temporary DB (Server does not keep history!).
5.  **Bob's App:** Receives message.
    *   Sends ACK "Delivered" back to Server -> Alice (Double Tick âœ“âœ“).
6.  **Bob Reads:**
    *   Sends ACK "Read" back to Server -> Alice (Blue Ticks).

### TypeScript: Acknowledge Logic

```typescript
type MessageStatus = 'SENT' | 'DELIVERED' | 'READ';

class ChatServer {
  // Map UserID -> WebSocket Connection
  activeConnections: Map<string, WebSocket> = new Map();
  
  // Handling a message from Alice
  async handleMessage(msg: EncryptedMessage, fromUser: string, toUser: string) {
    // 1. Persist temporarily (Safety)
    const msgId = await db.saveTemp(msg);
    
    // 2. ACK to Alice (Sent)
    this.sendAck(fromUser, msgId, 'SENT');
    
    // 3. Try Deliver
    const bobSocket = this.activeConnections.get(toUser);
    
    if (bobSocket && bobSocket.readyState === WebSocket.OPEN) {
      bobSocket.send(JSON.stringify(msg));
    } else {
      console.log(`User ${toUser} offline. Message stored.`);
      // Will be delivered when Bob connects 'SYNC' event
    }
  }

  // Handling ACK from Bob
  handleAck(msgId: string, fromUser: string, status: MessageStatus) {
    // Lookup who sent the original message (Alice)
    const originalSender = await db.getSender(msgId);
    
    // Forward the ACK to Alice so she sees Blue Ticks
    const aliceSocket = this.activeConnections.get(originalSender);
    if (aliceSocket) {
      aliceSocket.send(JSON.stringify({ type: 'ACK', msgId, status }));
    }
    
    if (status === 'DELIVERED') {
      // Bob has it, we can delete from Server DB now (if strictly ephemeral)
      await db.deleteTemp(msgId);
    }
  }
}
```

---

## 6. End-to-End Encryption (Signal Protocol) ðŸ”

Server stores **only** encrypted blobs. It has NO IDEA what the message says.

**Key Concepts:**
1.  **Identity Key:** Long-term key (Like a fingerprint).
2.  **Pre-Keys:** One-time keys generated by Bob and stored on Server.
    *   Alice fetches Bob's "Pre-Key" bundle from server.
3.  **Session Key:** Alice generates a shared secret using Bob's Pre-Key.
4.  **Double Ratchet:** Every message changes the key. If you hack one key, you can't read past messages (Forward Secrecy) or future messages (Backward Secrecy).

---

## 7. Group Chats (Select Complexity)

**Problem:** Alice sends a message to a group of 100 people.
**Solution:** Server-Side Fanout.
1.  Alice sends **1** message to Server.
2.  Server looks up Group Members `[B, C, D... Z]`.
3.  Server copies message and pushes to 99 connections.

**Encryption Complexity:**
*   Alice generates a "Sender Key".
*   Alice encrypts this key individually for B, C, D... (Pairwise).
*   Alice sends the actual message encrypted ONCE with the "Sender Key".
*   Everyone uses the Sender Key to decrypt.

---

## 8. Real World Applications ðŸŒ

### History Storage
*   **WhatsApp:** Stores history on **Phone**. Backups go to iCloud/GDrive. Server is lean.
*   **Telegram/Messenger:** Stores history on **Server**. Requires massive Distributed Cloud Database (HBase/Cassandra). Allows multi-device sync easily.

### Push Notifications
*   When App is closed (Killed background process), WebSockets die.
*   Server must use **APNS (Apple)** or **FCM (Google)** to wake up the phone/show notification.

---

## 9. Interview Tips ðŸ’¡

1.  **Erlang:** Mention it. "WhatsApp is famous for using Erlang to handle millions of concurrent connections on a single box."
2.  **Last Seen:** "We don't update DB on every heartbeat. We update Redis. Only persist to DB if last update > 5 mins ago."
3.  **Media:** "Media doesn't go through the WebSocket. We upload image to HTTP S3, get a URL, and send the *URL* (thumbnail hash) via WebSocket."
